import { ComponentFixture, TestBed } from '@angular/core/testing';
import { NotificationSearchResultComponent } from './notification-search-result.component';
import { ClrDatagridModule } from '@clr/angular';
import { ConfirmDialogService } from '../../services/confirm-dialog.service';
import { NotificationWeatherEvent } from '../../models/notification';
import { of } from 'rxjs';
import { NO_ERRORS_SCHEMA } from '@angular/core';

describe('NotificationSearchResultComponent', () => {
  let component: NotificationSearchResultComponent;
  let fixture: ComponentFixture<NotificationSearchResultComponent>;
  let confirmDialogService: ConfirmDialogService;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [NotificationSearchResultComponent],
      schemas: [NO_ERRORS_SCHEMA],
      imports: [ClrDatagridModule],
      providers: [
        {
          provide: ConfirmDialogService,
          useValue: {
            confirm: jasmine.createSpy('confirm').and.returnValue(of(true)),
          },
        },
      ],
    }).compileComponents();

    fixture = TestBed.createComponent(NotificationSearchResultComponent);
    component = fixture.componentInstance;
    confirmDialogService = TestBed.inject(ConfirmDialogService);
    fixture.detectChanges();
  });

  // ... (keep all existing test cases) ...

  describe('showConfirmationDialog', () => {
    it('should emit selected items when confirmation is true', async () => {
      const weatherEvent = {
        weatherEventId: 1,
        weatherEvent: 'Test Event',
        status: 'active',
        isMapped: 1
      } as NotificationWeatherEvent;

      component.selected = [weatherEvent];
      const emitSpy = spyOn(component.onSelectChange, 'emit');

      await component.showConfirmationDialog(weatherEvent);

      expect(confirmDialogService.confirm).toHaveBeenCalledWith(
        `You selected <b>${weatherEvent.weatherEvent}</b>, are you sure you want to continue?`,
        'Ok',
        'Cancel'
      );
      expect(emitSpy).toHaveBeenCalledWith([weatherEvent]);
    });

    it('should remove item and emit updated selection when confirmation is false', async () => {
      const weatherEvent = {
        weatherEventId: 1,
        weatherEvent: 'Test Event',
        status: 'active',
        isMapped: 1
      } as NotificationWeatherEvent;

      component.selected = [weatherEvent];
      component.previousSelected = [weatherEvent];
      const emitSpy = spyOn(component.onSelectChange, 'emit');

      (confirmDialogService.confirm as jasmine.Spy).and.returnValue(Promise.resolve(false));
      
      await component.showConfirmationDialog(weatherEvent);

      expect(component.selected).toEqual([]);
      expect(component.previousSelected).toEqual([]);
      expect(emitSpy).toHaveBeenCalledWith([]);
    });

    it('should only remove the specified item when confirmation is false', async () => {
      const weatherEvent1 = {
        weatherEventId: 1,
        weatherEvent: 'Test Event 1',
        status: 'active',
        isMapped: 1
      } as NotificationWeatherEvent;

      const weatherEvent2 = {
        weatherEventId: 2,
        weatherEvent: 'Test Event 2',
        status: 'active',
        isMapped: 1
      } as NotificationWeatherEvent;

      component.selected = [weatherEvent1, weatherEvent2];
      component.previousSelected = [weatherEvent1, weatherEvent2];
      const emitSpy = spyOn(component.onSelectChange, 'emit');

      (confirmDialogService.confirm as jasmine.Spy).and.returnValue(Promise.resolve(false));
      
      await component.showConfirmationDialog(weatherEvent1);

      expect(component.selected).toEqual([weatherEvent2]);
      expect(component.previousSelected).toEqual([weatherEvent2]);
      expect(emitSpy).toHaveBeenCalledWith([weatherEvent2]);
    });
  });

  // ... (keep all other existing test cases) ...
});
