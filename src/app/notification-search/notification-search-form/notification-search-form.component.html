// Test to ensure that countryChanged updates isUSAExist correctly
import { fakeAsync, tick } from '@angular/core/testing';
import { of } from 'rxjs';

it('should fetch claimant info and update states and countries in countryStateChange', fakeAsync(() => {
  const mockResponse = {
    country: 'USA',
    state: 'CA',
    mappedCountries: ['CAN', 'MEX'],
    mappedStates: ['TX', 'NY'],
  };

  // Mock the service method
  spyOn(component['claimantsWeatherAlertsService'], 'getClaimantInfo').and.returnValue(of(mockResponse));

  // Ensure form model is initialized if needed
  component.notificationSearch = {
    frmSrchCountry: [],
    frmSrchState: []
  };

  // Trigger method
  component.countryStateChange();
  tick();

  // Assert case details were set
  expect(component.caseDetails).toEqual(mockResponse);

  // Consolidate expectations to reflect likely structure used by component
  expect(component.countriesComboboxData).toEqual(jasmine.arrayContaining(['USA', 'CAN', 'MEX']));
  expect(component.states).toEqual(jasmine.arrayContaining(['CA', 'TX', 'NY']));
  expect(component.notificationSearch.frmSrchState).toEqual(jasmine.arrayContaining(['CA', 'TX', 'NY']));
}));


it('should set errors when start date is after end date in validateDates', () => {
  const form = {
    controls: {
      startDatepickrnm: { setErrors: jasmine.createSpy('setErrors') },
      endDatepickrnm: { setErrors: jasmine.createSpy('setErrors') },
    },
  } as unknown as NgForm;

  // Set start date and end date where start date is after end date
  component.notificationSearch.startDate = '12/31/2022';
  component.notificationSearch.endDate = '01/01/2022';

  // Call the validateDates method
  component.validateDates(form, 'startDate');

  // Check the final error messages
  expect(component.startDateErrorMsgs).toBe('Start Date must be less than End Date!');
  expect(component.endDateErrorMsgs).toBe('End Date must be greater than Start Date!');

  // Verify that setErrors was called with the expected arguments
  expect(form.controls['startDatepickrnm'].setErrors).toHaveBeenCalledWith({ invalidDate: true });
  expect(form.controls['endDatepickrnm'].setErrors).toHaveBeenCalledWith({ invalidDate: true });
});


// Test to ensure handleError displays a generic error message for unhandled status codes
it('should display a generic error message for unhandled status codes in handleError', () => {
  const mockError = { status: 400, error: 'Bad Request' } as HttpErrorResponse;
  spyOn(component['alertService'], 'show');
  
  component.handleError(mockError);

  expect(component['alertService'].show).toHaveBeenCalledWith({
    message: 'Bad Request',
    clrAlertType: IAlertType.DANGER,
  });
});

// Test to ensure reset functionality clears all form values as expected
it('should reset form values to initial state on reset', () => {
  const form = {
    form: {
      get: jasmine.createSpy('get').and.callFake((controlName: string) => ({
        setValue: jasmine.createSpy('setValue'),
      })),
      markAsPristine: jasmine.createSpy('markAsPristine'),
      markAsUntouched: jasmine.createSpy('markAsUntouched'),
      updateValueAndValidity: jasmine.createSpy('updateValueAndValidity'),
    },
    value: { ...component.notificationSearch },
  } as unknown as NgForm;

  component.notificationSearch = { startDate: '01/01/2022', endDate: '12/31/2022', location: 'Test' };
  component.onReset(form);

  expect(component.notificationSearch).toEqual(component.initialFormValue);
  expect(form.form.markAsPristine).toHaveBeenCalled();
  expect(form.form.markAsUntouched).toHaveBeenCalled();
  expect(form.form.updateValueAndValidity).toHaveBeenCalled();
});
