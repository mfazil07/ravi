import { of } from 'rxjs';
import { fakeAsync, tick } from '@angular/core/testing';

it('should fetch claimant info and update states and countries in countryStateChange', fakeAsync(() => {
  const mockClaimantInfo = {
    country: 'USA',
    state: 'CA',
    mappedCountries: ['CAN', 'MEX'],
    mappedStates: ['TX', 'NY'],
  };

  const mockResponse = [mockClaimantInfo];

  // Ensure the method returns the correct type (array)
  spyOn(component['claimantsWeatherAlertsService'], 'getClaimantInfo').and.returnValue(of(mockResponse));

  // Required mock setup for notificationSearch
  component.notificationSearch = {
    frmSrchCountry: [],
    frmSrchState: []
  };

  // Run the method
  component.countryStateChange();
  tick(); // Let async code run

  // Assertions
  expect(component.caseDetails).toEqual(mockClaimantInfo);

  expect(component.countriesComboboxData).toEqual([
    { key: 'USA', value: 'USA' },
    { key: 'CAN', value: '' },
    { key: 'MEX', value: '' },
  ]);

  expect(component.states).toEqual([
    { key: 'CA', value: 'CA' },
    { key: 'TX', value: 'TX' },
    { key: 'NY', value: 'NY' },
  ]);

  expect(component.notificationSearch.frmSrchState).toEqual([
    { key: 'CA', value: 'CA' },
    { key: 'TX', value: 'TX' },
    { key: 'NY', value: 'NY' },
  ]);
}));


it('should set errors when start date is after end date in validateDates', () => {
  const form = {
    controls: {
      startDatepickrnm: { setErrors: jasmine.createSpy('setErrors') },
      endDatepickrnm: { setErrors: jasmine.createSpy('setErrors') },
    },
  } as unknown as NgForm;

  // Set start date and end date where start date is after end date
  component.notificationSearch.startDate = '12/31/2022';
  component.notificationSearch.endDate = '01/01/2022';

  // Call the validateDates method
  component.validateDates(form, 'startDate');

  // Check the final error messages
  expect(component.startDateErrorMsgs).toBe('Start Date must be less than End Date!');
  expect(component.endDateErrorMsgs).toBe('End Date must be greater than Start Date!');

  // Verify that setErrors was called with the expected arguments
  expect(form.controls['startDatepickrnm'].setErrors).toHaveBeenCalledWith({ invalidDate: true });
  expect(form.controls['endDatepickrnm'].setErrors).toHaveBeenCalledWith({ invalidDate: true });
});


// Test to ensure handleError displays a generic error message for unhandled status codes
it('should display a generic error message for unhandled status codes in handleError', () => {
  const mockError = { status: 400, error: 'Bad Request' } as HttpErrorResponse;
  spyOn(component['alertService'], 'show');
  
  component.handleError(mockError);

  expect(component['alertService'].show).toHaveBeenCalledWith({
    message: 'Bad Request',
    clrAlertType: IAlertType.DANGER,
  });
});

// Test to ensure reset functionality clears all form values as expected
it('should reset form values to initial state on reset', () => {
  const form = {
    form: {
      get: jasmine.createSpy('get').and.callFake((controlName: string) => ({
        setValue: jasmine.createSpy('setValue'),
      })),
      markAsPristine: jasmine.createSpy('markAsPristine'),
      markAsUntouched: jasmine.createSpy('markAsUntouched'),
      updateValueAndValidity: jasmine.createSpy('updateValueAndValidity'),
    },
    value: { ...component.notificationSearch },
  } as unknown as NgForm;

  component.notificationSearch = { startDate: '01/01/2022', endDate: '12/31/2022', location: 'Test' };
  component.onReset(form);

  expect(component.notificationSearch).toEqual(component.initialFormValue);
  expect(form.form.markAsPristine).toHaveBeenCalled();
  expect(form.form.markAsUntouched).toHaveBeenCalled();
  expect(form.form.updateValueAndValidity).toHaveBeenCalled();
});
